# Todo In-Memory Python Console App Constitution

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)
All development MUST follow the Spec-Driven Development (SDD) workflow. Specifications are generated first using Spec-Kit Plus compatible Markdown format. Implementation code is generated by Claude Code from these specifications. No manual coding by humans; all code generation is AI-driven based on complete, unambiguous specifications.

### II. Clean Architecture
The application MUST follow clean architecture principles with clear separation of concerns:
- Domain entities (e.g., Task) at the core
- Use cases (e.g., AddTask, DeleteTask) as business logic
- Interfaces (e.g., TaskRepository) for abstraction
- Console interface as the presentation layer
- In-memory storage as the infrastructure layer

### III. Technology Constraints (MANDATORY)
Strict adherence to the following technology stack:
- Python 3.13+ (minimum version requirement)
- In-memory storage only (NO database, NO file persistence)
- Console-based interface (text input/output via stdin/stdout/stderr)
- Spec-Kit Plus compatibility for all specifications
- Claude Code tooling for AI-driven code generation

### IV. Feature Completeness
All 5 Basic Level features MUST be fully specified and implemented:
1. Add Task
2. Delete Task
3. Update Task
4. View Task List
5. Mark Task as Complete / Incomplete

Each feature must have complete user stories, functional requirements, acceptance criteria, and test cases.

### V. Specification Quality (NON-NEGOTIABLE)
All specifications MUST be:
- Complete: Every requirement explicitly addressed
- Unambiguous: Clear enough for AI code generation without clarification
- Testable: All requirements have measurable acceptance criteria
- Internally consistent: No contradictions between spec.md, plan.md, and tasks.md
- Spec-Kit Plus compliant: Adheres to Spec-Kit Plus Markdown formatting standards

### VI. Knowledge Capture
Every development interaction MUST be documented:
- Prompt History Records (PHRs) created for all user prompts
- Architectural Decision Records (ADRs) suggested for significant decisions
- All specifications, plans, and tasks stored in `specs/<feature>/` directory
- PHR routing: constitution → `history/prompts/constitution/`, feature-specific → `history/prompts/<feature-name>/`, general → `history/prompts/general/`

## Technology Standards

### Python Requirements
- Minimum Python version: 3.13
- Use type hints for all function signatures
- Follow PEP 8 style guidelines
- Use standard library where possible; external dependencies must be justified

### Console Interface Standards
- Text-based input/output protocol: stdin/args → stdout, errors → stderr
- Support both human-readable and structured (JSON) output formats
- Clear, user-friendly error messages
- Command-line argument parsing with help text

### Storage Constraints
- In-memory storage only (dictionaries, lists, or similar data structures)
- NO file system persistence
- NO database connections
- Data exists only during application runtime

## Development Workflow

### Specification Phase
1. Use `todo-spec-architect` agent to generate specifications
2. Create `spec.md` with user stories and functional requirements
3. Create `plan.md` with architectural design and decisions
4. Create `tasks.md` with testable, granular tasks
5. Validate all specifications for completeness and consistency

### Implementation Phase
1. Generate code from specifications using Claude Code
2. Follow Red-Green-Refactor TDD cycle
3. Write tests first, then implement to pass tests
4. Maintain smallest viable change principle
5. Reference code precisely with line numbers

### Quality Gates
- All specifications must pass quality checklist before implementation
- All code must have corresponding tests
- All tests must pass before considering feature complete
- PHR must be created after every significant interaction
- ADR suggested for architecturally significant decisions

## Architecture Principles

### Domain-Driven Design
- Core domain entities are independent of infrastructure
- Business logic encapsulated in use cases
- Interfaces define contracts, not implementations

### Interface Contracts
- All interfaces must define: inputs, outputs, error conditions
- Error handling must be explicit and user-friendly
- Input validation at boundaries

### Non-Functional Requirements
- Performance: Minimal overhead for in-memory CLI (sub-second response times)
- Reliability: Basic error handling with clear user messages
- Security: Input validation for CLI (no external threats expected)
- Maintainability: Clean code structure supporting future extensibility

## Governance

This constitution supersedes all other development practices. All development work MUST comply with these principles.

**Amendment Process:**
- Amendments require documentation of rationale
- Approval from project stakeholders
- Migration plan for existing code/specifications
- Update to constitution version and date

**Compliance Verification:**
- All PRs/reviews must verify constitution compliance
- Complexity must be justified against principles
- Use `.specify/memory/constitution.md` for runtime development guidance
- Violations must be documented and addressed

**Version**: 1.0.0 | **Ratified**: 2025-12-28 | **Last Amended**: 2025-12-28
